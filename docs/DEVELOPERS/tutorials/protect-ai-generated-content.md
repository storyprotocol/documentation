---
title: Protect Dall-E AI-Generated Content
excerpt: Learn how to protect Dall-E AI-Generated Content using Story.
deprecated: false
hidden: true
metadata:
  title: ''
  description: ''
  robots: index
next:
  description: ''
---
In this tutorial, you will learn how to protect Dall-E 2 AI-Generated Content by registering it on Story.

## The Explanation

Let's say you have some off-chain IP (ex. a book, a character, a drawing, etc). In order to register that IP on Story, you first need to mint an NFT to represent that IP, and then register that NFT on Story, turning it into an [ðŸ§© IP Asset](doc:ip-asset). The below tutorial will walk you through 2 different ways to do that (step 5a and step 5b).

## 0. Before you Start

There are a few steps you have to complete before you can start the tutorial.

1. Add your Story Network Testnet wallet's private key to `.env` file:

```yaml .env
WALLET_PRIVATE_KEY=
```

2. Go to [Pinata](https://pinata.cloud/) and create a new API key. Add the JWT to your `.env` file:

```yaml .env
PINATA_JWT=
```

3. Go to [OpenAI](https://platform.openai.com/settings/organization/api-keys) and create a new API key. Add the new key to your `.env` file:

```yaml .env
OPENAI_API_KEY=
```

4. Add your preferred RPC URL to your `.env` file. You can just use the public default one we provide:

```yaml .env
RPC_PROVIDER_URL=https://rpc.odyssey.storyrpc.io
```

5. Install the dependencies:

```Text Terminal
npm install @story-protocol/core-sdk @pinata/sdk viem openai
```

## 1. Generate an Image

```typescript main.ts
import OpenAI from 'openai'

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
})

const image = await openai.images.generate({ 
  model: 'dall-e-2', 
  prompt: 'A cute baby sea otter' 
});

console.log(image.data[0].url) // the url to the newly created image
```

## 2. Set up your Story Config

* Associated docs: [TypeScript SDK Setup](doc:typescript-sdk-setup)

```javascript main.ts
import { StoryClient, StoryConfig } from "@story-protocol/core-sdk";
import { http } from "viem";
import { privateKeyToAccount, Address, Account } from "viem/accounts";

// previous code here ...

const privateKey: Address = `0x${process.env.WALLET_PRIVATE_KEY}`;
const account: Account = privateKeyToAccount(privateKey);

const config: StoryConfig = {
  account: account,
  transport: http(process.env.RPC_PROVIDER_URL),
  chainId: "odyssey",
};
const client = StoryClient.newClient(config);
```

## 3. Set up your IP Metadata

View the [IPA Metadata Standard](doc:ipa-metadata-standard) and construct your metadata for your IP. You can use the `generateIpMetadata` function to properly format your metadata and ensure it is of the correct type, as shown below:

```javascript main.ts
import { IpMetadata } from "@story-protocol/core-sdk";

// previous code here...

const ipMetadata: IpMetadata = client.ipAsset.generateIpMetadata({
  title: 'Dall-E 2 Image',
  description: 'An image generated by Dall-E 2',
  ipType: 'image',
  attributes: [
    {
      key: 'Model',
      value: 'dall-e-2',
    },
    {
      key: 'Prompt',
      value: 'A cute baby sea otter',
    },
  ],
  creators: [
    {
      name: 'Jacob Tucker',
      contributionPercent: 100,
      address: account.address,
    },
  ],
})
```

## 4. Set up your NFT Metadata

The NFT Metadata follows the [ERC-721 Metadata Standard](https://eips.ethereum.org/EIPS/eip-721).

```javascript main.ts
// previous code here...

const nftMetadata = {
  name: 'NFT representing ownership of our image',
  description: 'This NFT represents ownership of the image generated by Dall-E 2',
  image: image.data[0].url,
  attributes: [
    {
      key: 'Model',
      value: 'dall-e-2',
    },
    {
      key: 'Prompt',
      value: 'A cute baby sea otter',
    },
  ],
}
```

## 5. Upload your IP and NFT Metadata to IPFS

In a separate file, create a function to upload your IP & NFT Metadata objects to IPFS:

```javascript utils/uploadToIpfs.ts
const pinataSDK = require("@pinata/sdk");

export async function uploadJSONToIPFS(jsonMetadata): Promise<string> {
  const pinata = new pinataSDK({ pinataJWTKey: process.env.PINATA_JWT });
  const { IpfsHash } = await pinata.pinJSONToIPFS(jsonMetadata);
  return IpfsHash;
}
```

You can then use that function to upload your metadata, as shown below:

```javascript main.ts
import { uploadJSONToIPFS } from "./utils/uploadToIpfs";
import { createHash } from "crypto";

// previous code here...

const ipIpfsHash = await uploadJSONToIPFS(ipMetadata);
const ipHash = createHash("sha256")
  .update(JSON.stringify(ipMetadata))
  .digest("hex");
const nftIpfsHash = await uploadJSONToIPFS(nftMetadata);
const nftHash = createHash("sha256")
  .update(JSON.stringify(nftMetadata))
  .digest("hex");
```

## 6. Register the NFT as an IP Asset

In this step, we will use the [ðŸ“¦ SPG](doc:spg) to combine minting and registering our NFT into one transaction call.

First, in a separate script, you must create a new SPG NFT collection. You can do this with the SDK (view a working example [here](https://github.com/storyprotocol/typescript-tutorial/blob/main/scripts/utils/createSpgNftCollection.ts)):

> â“ Why do we have to do this?
>
> In order to use the `mintAndRegisterIpAssetWithPilTerms` function below, we'll have to deploy an SPG NFT collection so that the SPG can do the minting for us.
>
> Instead of doing this, you could technically write your own contract that implements [ISPGNFT](https://github.com/storyprotocol/protocol-periphery-v1/blob/main/contracts/interfaces/ISPGNFT.sol). But an easy way to create a collection that implements `ISPGNFT` is just to call the `createCollection` function in the SPG contract using the SDK, as shown below.

```typescript createSpgNftCollection.ts
import { StoryClient, StoryConfig } from '@story-protocol/core-sdk'
import { http } from 'viem

const privateKey: Address = `0x${process.env.WALLET_PRIVATE_KEY}`
const account: Account = privateKeyToAccount(privateKey)

const config: StoryConfig = {
  account: account,
  transport: http(process.env.RPC_PROVIDER_URL),
  chainId: 'odyssey',
}
const client = StoryClient.newClient(config)

const newCollection = await client.nftClient.createNFTCollection({
  name: 'Dall-E NFTs',
  symbol: 'DALLE',
  isPublicMinting: true,
  mintOpen: true,
  mintFeeRecipient: zeroAddress,
  contractURI: '',
  txOptions: { waitForTransaction: true },
})

console.log(
  `New SPG NFT collection created at transaction hash ${newCollection.txHash}`,
  `SPG NFT contract address: ${newCollection.spgNftContract}`
)
```

Look at the console output, and copy the SPG NFT contract address. Add that value as `SPG_NFT_CONTRACT_ADDRESS` to your `.env` file:

```Text env
SPG_NFT_CONTRACT_ADDRESS=
```

> ðŸ“˜ Note
>
> You only have to do the above step **once**. Once you have your SPG NFT contract address, you can register any amount of IPs and will **not** have to do this again.

The code below will mint an NFT, register it as an [ðŸ§© IP Asset](doc:ip-asset), set [License Terms](doc:license-terms) on the IP, and then set both NFT & IP metadata.

* Associated Docs: [Mint, Register, and Attach Terms](https://docs.story.foundation/docs/attach-terms-to-an-ip-asset#mint-nft-register-as-ip-asset-and-attach-terms)

```typescript main.ts
import {
  PIL_TYPE,
  CreateIpAssetWithPilTermsResponse,
} from "@story-protocol/core-sdk";
import { Address } from "viem";

// previous code here ...

const response: CreateIpAssetWithPilTermsResponse =
  await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({
    spgNftContract: process.env.SPG_NFT_CONTRACT_ADDRESS as Address,
    pilType: PIL_TYPE.NON_COMMERCIAL_REMIX,
    ipMetadata: {
      ipMetadataURI: `https://ipfs.io/ipfs/${ipIpfsHash}`,
      ipMetadataHash: `0x${ipHash}`,
      nftMetadataURI: `https://ipfs.io/ipfs/${nftIpfsHash}`,
      nftMetadataHash: `0x${nftHash}`,
    },
    txOptions: { waitForTransaction: true },
  });

console.log(
  `Root IPA created at transaction hash ${response.txHash}, IPA ID: ${response.ipId}`
);
console.log(
  `View on the explorer: https://explorer.story.foundation/ipa/${response.ipId}`
);
```

## 7. Done!